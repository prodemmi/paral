package core

import (
	"fmt"
	parser "paral/antlr/antlr"
	"strconv"
	"strings"

	"github.com/antlr4-go/antlr/v4"
)

type CoreVisitor struct {
	*parser.BaseParalListener
	Core *Core
}

// VisitTerminal is called when a terminal node is visited.
func (s *CoreVisitor) VisitTerminal(node antlr.TerminalNode) {}

// ExitEveryRule is called when any rule is exited.
func (s *CoreVisitor) ExitEveryRule(ctx antlr.ParserRuleContext) {}

// EnterProgram is called when production program is entered.
func (s *CoreVisitor) EnterProgram(ctx *parser.ProgramContext) {
	Info("Starting to parse .paral file", ctx.GetStop().GetInputStream().GetSourceName(), ctx.GetStop().GetLine(), ctx.GetStop().GetColumn())
}

// ExitProgram is called when production program is exited.
func (s *CoreVisitor) ExitProgram(ctx *parser.ProgramContext) {
	Info("Finished parsing .paral file", ctx.GetStop().GetInputStream().GetSourceName(), ctx.GetStop().GetLine(), ctx.GetStop().GetColumn())
}

// ExitLine is called when production line is exited.
func (s *CoreVisitor) ExitLine(ctx *parser.LineContext) {}

// ExitVariable_def is called when production variable_def is exited.
func (s *CoreVisitor) ExitVariable_def(ctx *parser.Variable_defContext) {
	name := ctx.IDENTIFIER().GetText()
	filename := ctx.GetStop().GetInputStream().GetSourceName()
	line := ctx.GetStop().GetLine()
	column := ctx.GetStop().GetColumn()

	var value interface{}
	var _type string

	if ctx.Value_expr() != nil {
		switch val := ctx.Value_expr().(type) {
		case *parser.StringContext:
			value = TrimQuotes(val.GetText())
			_type = "string"
		case *parser.SingleQuoteStringContext:
			value = TrimQuotes(val.GetText())
			_type = "string"
		case *parser.NumberContext:
			num, err := strconv.Atoi(val.GetText())
			if err != nil {
				ThrowSyntaxError(fmt.Sprintf("Invalid number: %s", val.GetText()), filename, line, column)
			}
			value = num
			_type = "number"
		case *parser.BoolContext:
			value = val.GetText() == "true"
			_type = "bool"
		case *parser.DurationContext:
			value = val.GetText()
			_type = "duration"
		default:
			ThrowSyntaxError("Unknown value type in variable definition", filename, line, column)
		}
	} else if ctx.List_expr() != nil {
		value = ExtractListValues(ctx.List_expr())
		_type = "list"
	}

	s.Core.AddVar(Var{Name: name, Value: value, Type: _type})
}

// ExitMatrix_def is called when production matrix_def is exited.
func (s *CoreVisitor) ExitMatrix_def(ctx *parser.Matrix_defContext) {
	name := ctx.IDENTIFIER().GetText()
	filename := ctx.GetStop().GetInputStream().GetSourceName()
	line := ctx.GetStop().GetLine()
	column := ctx.GetStop().GetColumn()

	var matrixValues [][]interface{}
	for _, list := range ctx.AllList_expr() {
		row := ExtractListValues(list)
		if len(row) == 0 {
			Warn(fmt.Sprintf("Empty list in matrix %s", name), filename, line, column)
		}
		matrixValues = append(matrixValues, row)
	}

	s.Core.AddMatrix(Matrix{Name: name, Values: matrixValues})
}

// ExitList_expr is called when production list_expr is exited.
func (s *CoreVisitor) ExitList_expr(ctx *parser.List_exprContext) {}

// ExitComment_def is called when production comment_def is exited.
func (s *CoreVisitor) ExitComment_def(ctx *parser.Comment_defContext) {}

// ExitString is called when production string is exited.
func (s *CoreVisitor) ExitString(ctx *parser.StringContext) {}

// ExitNumber is called when production number is exited.
func (s *CoreVisitor) ExitNumber(ctx *parser.NumberContext) {}

// ExitBool is called when production bool is exited.
func (s *CoreVisitor) ExitBool(ctx *parser.BoolContext) {}

// ExitDuration is called when production duration is exited.
func (s *CoreVisitor) ExitDuration(ctx *parser.DurationContext) {}

// ExitJob_header is called when production job_header is exited.
func (s *CoreVisitor) ExitJob_header(ctx *parser.Job_headerContext) {}

// ExitCmd_line is called when production cmd_line is exited.
func (s *CoreVisitor) ExitCmd_line(ctx *parser.Cmd_lineContext) {}

// ExitCmd_expr is called when production cmd_expr is exited.
func (s *CoreVisitor) ExitCmd_expr(ctx *parser.Cmd_exprContext) {}

// ExitCmd_tokens is called when production cmd_tokens is exited.
func (s *CoreVisitor) ExitCmd_tokens(ctx *parser.Cmd_tokensContext) {}

// ExitJob_def is called when production job_def is exited.
func (s *CoreVisitor) ExitJob_def(ctx *parser.Job_defContext) {
	name := ctx.Job_header().IDENTIFIER().GetText()
	filename := ctx.GetStop().GetInputStream().GetSourceName()
	job := NewJob(name, filename)
	var commands []Command

	// Process job-level directives (@id, @name, @depend, @for, etc.)
	for _, dirDefCtx := range ctx.AllJob_directive_def() {
		if dirDefCtx.IDENTIFIER() == nil {
			ThrowSyntaxError("Missing directive name", filename, dirDefCtx.GetStop().GetLine(), dirDefCtx.GetStop().GetColumn())
			continue
		}
		jobDirName := dirDefCtx.IDENTIFIER().GetText()
		var jobDirArgs []interface{}
		dirLine := dirDefCtx.GetStop().GetLine()
		dirColumn := dirDefCtx.GetStop().GetColumn()

		for _, dirValue := range dirDefCtx.AllJob_directive_value() {
			if dirValue.Value_expr() != nil {
				jobDirArgs = append(jobDirArgs, ExtractValue(dirValue.Value_expr()))
			} else if dirValue.IDENTIFIER() != nil {
				jobDirArgs = append(jobDirArgs, dirValue.IDENTIFIER().GetText())
			} else if dirValue.MATRIX_REF() != nil {
				jobDirArgs = append(jobDirArgs, dirValue.MATRIX_REF().GetText())
			} else if dirValue.REF() != nil {
				jobDirArgs = append(jobDirArgs, dirValue.REF().GetText())
			} else if dirValue.VALUE() != nil {
				jobDirArgs = append(jobDirArgs, dirValue.VALUE().GetText())
			}
		}

		if err := job.AddJobDirective(jobDirName, jobDirArgs...); err != nil {
			ThrowSyntaxError(err.Error(), filename, dirLine, dirColumn)
		}
	}

	// Process commands
	for _, cmdLineCtx := range ctx.AllCmd_line() {
		cmdCtx := cmdLineCtx.Cmd_expr()
		var cmdTokens []string
		var cmdDirectives []CMDDirective
		cmdLine := cmdLineCtx.GetStart().GetLine()
		cmdColumn := cmdLineCtx.GetStart().GetColumn()

		// Process command directive (@once, @try, @concat, etc.)
		if cmdCtx.Cmd_directive() != nil {
			directive := cmdCtx.Cmd_directive()
			if directive.Cmd_directive_iden() == nil || directive.Cmd_directive_iden().IDENTIFIER() == nil {
				ThrowSyntaxError("Missing command directive name", filename, cmdLine, cmdColumn)
				continue
			}
			dirName := directive.Cmd_directive_iden().IDENTIFIER().GetText()
			var args []interface{}

			for _, directiveValue := range directive.AllCmd_directive_value() {
				for _, arg := range directiveValue.AllDirective_arg() {
					if arg.Value_expr() != nil {
						args = append(args, ExtractValue(arg.Value_expr()))
					} else if arg.IDENTIFIER() != nil {
						args = append(args, arg.IDENTIFIER().GetText())
					} else if arg.MATRIX_REF() != nil {
						args = append(args, arg.MATRIX_REF().GetText())
					} else if arg.REF() != nil {
						args = append(args, arg.REF().GetText())
					} else if arg.VALUE() != nil {
						args = append(args, arg.VALUE().GetText())
					}
				}
			}

			cmdDirective, err := job.AddCMDDirective(dirName, args)
			if err != nil {
				ThrowSyntaxError(err.Error(), filename, cmdLine, cmdColumn)
			}
			cmdDirectives = append(cmdDirectives, *cmdDirective)
		}

		// Collect command tokens
		for _, tokenCtx := range cmdCtx.AllCmd_tokens() {
			if tokenCtx.IDENTIFIER() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.IDENTIFIER().GetText())
			} else if tokenCtx.STRING() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.STRING().GetText())
			} else if tokenCtx.SINGLE_QUOTE_STRING() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.SINGLE_QUOTE_STRING().GetText())
			} else if tokenCtx.NUMBER() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.NUMBER().GetText())
			} else if tokenCtx.MATRIX_REF() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.MATRIX_REF().GetText())
			} else if tokenCtx.ARG() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.ARG().GetText())
			} else if tokenCtx.SINGLE_DASH_ARG() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.SINGLE_DASH_ARG().GetText())
			} else if tokenCtx.EQUALS() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.EQUALS().GetText())
			} else if tokenCtx.REF() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.REF().GetText())
			} else if tokenCtx.URL() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.URL().GetText())
			} else if tokenCtx.VALUE() != nil {
				cmdTokens = append(cmdTokens, tokenCtx.VALUE().GetText())
			} else if tokenCtx.BSL_NEWLINE() != nil {
				cmdTokens = append(cmdTokens, " ") // Replace backslash-newline with space
			}
		}

		// Join tokens into a single command string
		cmdString := strings.Join(cmdTokens, " ")

		// Check for @for directive to resolve matrix or list placeholders
		hasFor := false
		var forValue string
		for _, dir := range job.Directives {
			if dir.Type == "for" {
				hasFor = true
				if value, ok := dir.Value.([]interface{}); ok && len(value) > 0 {
					if str, ok := value[0].(string); ok {
						forValue = str
					} else {
						ThrowRuntimeError(fmt.Sprintf("Invalid value for @for: %v", value), filename, cmdLine, cmdColumn)
						return
					}
				} else {
					ThrowRuntimeError("Invalid or missing value for @for directive", filename, cmdLine, cmdColumn)
					return
				}
				break
			}
		}

		if hasFor {
			var values [][]interface{}
			// Check if it's a matrix
			if matrixValues, exists := s.Core.ResolveMatrix(forValue); exists {
				values = matrixValues
			} else if varValues, exists := s.Core.ResolveVariable(forValue); exists {
				// Handle list variable
				if varValues.Type == "list" {
					if list, ok := varValues.Value.([]interface{}); ok {
						for _, val := range list {
							values = append(values, []interface{}{val})
						}
					} else {
						ThrowRuntimeError(fmt.Sprintf("Invalid list variable %s for @for", forValue), filename, cmdLine, cmdColumn)
						return
					}
				} else if varValues.Type == "number" || varValues.Type == "string" || varValues.Type == "duration" || varValues.Type == "bool" {
					// Treat single value as a one-item list
					values = append(values, []interface{}{varValues.Value})
				} else {
					ThrowRuntimeError(fmt.Sprintf("Variable %s is not a list, matrix, or single value for @for", forValue), filename, cmdLine, cmdColumn)
					return
				}
			} else {
				ThrowRuntimeError(fmt.Sprintf("Matrix or variable %s not found for @for", forValue), filename, cmdLine, cmdColumn)
				return
			}

			// Handle empty lists or matrices
			if len(values) == 0 {
				// Add command directives as commands if present
				for _, dir := range cmdDirectives {
					if dir.Type == "print" || dir.Type == "concat" {
						if args, ok := dir.Value.([]interface{}); ok {
							for _, arg := range args {
								commands = append(commands, Command{
									Directive: []CMDDirective{{Type: dir.Type, Value: []interface{}{arg}}},
									CMD:       fmt.Sprintf("%v", arg),
								})
							}
						}
					}
				}
				if cmdString != "" {
					commands = append(commands, Command{
						Directive: cmdDirectives,
						CMD:       cmdString,
					})
				}
			} else {
				for _, row := range values {
					tempCmd := cmdString
					tempDirectives := make([]CMDDirective, len(cmdDirectives))
					copy(tempDirectives, cmdDirectives)

					// Replace matrix/list placeholders in command and directive arguments
					for i, val := range row {
						placeholder := "@value(" + fmt.Sprintf("%d", i+1) + ")"
						tempCmd = strings.ReplaceAll(tempCmd, placeholder, fmt.Sprintf("%v", val))
						for j, dir := range tempDirectives {
							if args, ok := dir.Value.([]interface{}); ok && (dir.Type == "concat" || dir.Type == "print") {
								newArgs := make([]interface{}, len(args))
								for k, arg := range args {
									newArgs[k] = strings.ReplaceAll(fmt.Sprintf("%v", arg), placeholder, fmt.Sprintf("%v", val))
								}
								tempDirectives[j].Value = newArgs
							}
						}
					}
					// Replace @value with the first value (if used without index)
					if len(row) > 0 {
						tempCmd = strings.ReplaceAll(tempCmd, "@value", fmt.Sprintf("%v", row[0]))
						for j, dir := range tempDirectives {
							if args, ok := dir.Value.([]interface{}); ok && (dir.Type == "concat" || dir.Type == "print") {
								newArgs := make([]interface{}, len(args))
								for k, arg := range args {
									newArgs[k] = strings.ReplaceAll(fmt.Sprintf("%v", arg), "@value", fmt.Sprintf("%v", row[0]))
								}
								tempDirectives[j].Value = newArgs
							}
						}
					}

					commands = append(commands, Command{
						Directive: tempDirectives,
						CMD:       tempCmd,
					})
				}
			}
		} else {
			// Add command directives as commands if present
			for _, dir := range cmdDirectives {
				if dir.Type == "print" || dir.Type == "concat" {
					if args, ok := dir.Value.([]interface{}); ok {
						for _, arg := range args {
							commands = append(commands, Command{
								Directive: []CMDDirective{{Type: dir.Type, Value: []interface{}{arg}}},
								CMD:       fmt.Sprintf("%v", arg),
							})
						}
					}
				}
			}
			if cmdString != "" {
				commands = append(commands, Command{
					Directive: cmdDirectives,
					CMD:       cmdString,
				})
			}
		}
	}

	job.Commands = commands
	s.Core.AddJob(*job)
}
